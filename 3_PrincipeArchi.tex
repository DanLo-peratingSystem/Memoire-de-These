\ifdefined\included
\else
\documentclass[french, a4paper, 11pt, twoside, pdftex]{StyleThese}
\include{formatAndDefs}
\sloppy



\begin{document}
\setcounter{chapter}{3} %% Numéro du chapitre précédent ;)
\dominitoc
\faketableofcontents
\fi

\chapter{Chapitre 3} \label{chap:3_PrincipeArchi}
\minitoc



		Ceci est un exemple de "maths" inclues dans le texte :  $\tau__{i,j}$ tel que $ e_{i,j} \leq s_{i+1, k}$  suivant le modèle $\tau_{1} \rightarrow \tau_2 \rightarrow \ldots \rightarrow \tau_n$. 

	   Mais ceci est un exemple d'équation / trucs de math qui prennent plusieurs lignes (non numéroté) :
		\begin{multline*}
		\forall i,j \in \mathbb{N}^*, \, \exists \, k \in  \mathbb{N}^*  \textrm{ tel que }  \\
		 succ(\tau_{i,j}) = \tau_{i+1,k} \textup{ avec } e_{i,j} \leq s_{i+1,k} \wedge e_{i,j} > s_{i+1,k-1}
		\end{multline*}

        Ceci est un exemple d'équations qu'on souhaite aligner tout propre sur la droite (aligné selon la position du saut de ligne ! )

		\begin{align*}
%%			\textup{Soit } succ(\tau_{i,j}) = \tau_{i+1,k} \textup{, alors :}	\\
		\textup{Soit } succ(\tau_{i,j}) = \tau_{i+1,k} \textup{, alors }
			succ(a_{i,j}) = a_{i+1,k} 	\\
			succ(s_{i,j}) = s_{i+1,k}	\\
			succ(e_{i,j}) = e_{i+1,k}	\\
		\textup{De même, si } succ^n(\tau_{i,j}) = \tau_{i+n,k} \textup{ alors }
			succ^n(a_{i,j}) = a_{i+n,k}		\\
			succ^n(s_{i,j}) = s_{i+n,k}		\\
			succ^n(e_{i,j}) = e_{i+n,k}
		\end{align*}

  		 Ce qui nous mène à la possibilité d'écrire des thèorèmes :

	\begin{theorem}[Condition de passage en mode dégradé]
		Tant que l'inéquation~\ref{eq:safe_cond} est vraie, alors il est toujours possible de garantir le respect de l'échéance bout-en-bout de la chaîne de tâches critiques pour la durée $W_{max}$ sans passer en mode dégradé.
		\begin{equation} \label{eq:safe_cond}
			RT(t) + rWCRT(\tau_i) + W_{max} + t_{SW} \leq D_c
		\end{equation}
	\end{theorem}

Ainsi que des preuves :

    \begin{proof}
		En présumant que (\ref{eq:safe_cond}) est respectée, on peut montrer qu'il est sûr d'attendre le prochain point de surveillance pour décider de changer de mode. \nline
		À l'instant de surveillance $t$, soit $t_{next}$ le prochain instant de surveillance.\nline
		Par définition, $t_{next} \leq t + W_{max}$. Alors $RT(t_{next}) \leq RT(t) + W_{max}$.
		Par conséquent, \smallbreak
		$RT(t_{next}) + rWCRT(\tau_i) + t_{SW} \leq RT(t) + rWCRT(\tau_i) + W_{max} + t_{SW}$. \nline
		Aussi, $rWCRT()$ ne peut que décroître avec le temps qui s'écoule. Par conséquent, %\smallbreak
		\[ rWCRT(t_{next}) \leq rWCRT(\tau_i)	\]
		et
		\[ RT(t_{next}) + rWCRT(t_{next}) + t_{SW} \leq RT(t) + rWCRT(\tau_i) + W_{max} + t_{SW} \]
		Étant donné que l'inégalité (\ref{eq:safe_cond}) est respecté, on a $RT(t_{next}) + rWCRT(t_{next}) + t_{SW} \leq D_c$.
		De ce fait, il sera sûr de passer en mode dégradé au prochain point de surveillance.
    \end{proof}
    Ou encore des définitions :

    \begin{definition}
        Ceci est une définition très simple.
    \end{definition}


        \cmnt{  %%%% VOUS AVIEZ VU QU'IL ETAIT POSSIBLE D'UTILISER CETTE BALISE POUR COMMENTER DES GROS MORCEAUX DE TEXTE ???
            One should note that what makes such approach possible is the evolution of the $rWCRT$ at run-time and as the $S(t)$ evolves. It would not be possible to apply such approach when it comes to monitor \& control individual tasks to guarantee their individual deadlines. For individual deadlines, our method would fit only if we are able to monitor tasks timing state ``inside" the tasks execution, i.e. instrumenting the tasks source code to add internal checkpoints. Such approach on individual tasks would discard by definition the use of black box software assumption for instance, and otherwise would need much higher refresh rate frequencies in order to follow individual tasks execution timing state. Such solution is presented for individual tasks in~\cite{kritikakou_dynascore_2017}.
            }


\ifdefined\included
\else
\bibliographystyle{StyleThese}
\bibliography{these}
\end{document}
\fi
